# -*- coding: utf-8 -*-
"""Hw3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k4MzzMdJ3eQsEgoGkh6w-QIH4TqCJZnM
"""

import numpy as np
import pandas as pd
import plotly.graph_objects as go

def preprocessData(data):
  datafile = pd.read_csv(data, sep = "\n", header=None )
  datafile.dropna()
  for i in range(0,len(datafile)):
    str1 = datafile.iloc[i,[0]].str.find("|",19)
    datafile.iloc[i,[0]] = datafile.iloc[i,[0]].str.slice(start = str1[0]+1)
    temp = datafile.iloc[i,[0]].str.find("http://")
    datafile.iloc[i,[0]] = datafile.iloc[i,[0]].str.slice(start = 0,stop = temp[0])
    datafile.iloc[i,[0]] = datafile.iloc[i,[0]].str.lower()
    
    datafile.iloc[i,[0]] = datafile.iloc[i,[0]].str.replace('[^a-zA-Z0-9 ]', '')
    #datafile.iloc[i,[0]] = datafile.iloc[i,[0]].str.split().sort_values()
    
    
  datafile.dropna()
  return datafile

datafiles = preprocessData("https://raw.githubusercontent.com/jkenney1123/hw3-data/main/goodhealth.txt")
datafiles.head

class kmeans:
    def __init__(self, dataFile,k1, header=True):
      self.k = k1
      self.df = dataFile
      self.classify = np.zeros((len(self.df),3))
      for i in range(len(self.classify)):
        self.classify[i,1] = -2
      self.matrix = np.zeros((len(self.df),self.k))
      self.centroids = self.df.sample(self.k).to_numpy()


    def distance_matrix(self):
      for u in range(0,self.k):
        center = self.centroids[u,0].split()
        for t in range(len(self.df)):
          test = self.df.iloc[t,0].split()
          count = 0
          length = 0
          if len(center) > len(test):
            size = len(center)
          else:
            size = len(test)
          for i in range(0,size):
            if len(center) > len(test):
              for j in range(0,len(test)):
                if center[i] == test[j]:
                  count = count + 1
                  length = length + len(center[i])
            else:
              for j in range(0,len(center)):
                if center[j] == test[i]:
                  count = count + 1
                  length = length + len(test[i])
          if count == 0:
            self.matrix[t,u] = 1
          elif count == len(center) or count == len(test):
            self.matrix[t,u] = 0
          else:
            self.matrix[t,u] = 1 - count/length



    def classification(self):#classify[current centr,previous centr, changed centroid 1 no 0 yes]
      for i in range(len(self.matrix)):
        min = 2
        for j in range(len(self.matrix[0])):
          if self.matrix[i,j] < min:
            min = self.matrix[i,j]
            self.classify[i,0] = j
        if self.classify[i,1] == -2:
          self.classify[i,1] = self.classify[i,0]
        else:#classifed again correctly then classify [i,2] = 1 else reclassified to another cluster and is 0
          if self.classify[i,0] == self.classify[i,1]:
            self.classify[i,2] = 1
            self.classify[i,1] = self.classify[i,0]
          else:
            self.classify[i,2] = 0
            self.classify[i,1] = self.classify[i,0]

    def check(self):
      for i in range(len(self.classify)):
        if self.classify[i,2] == 0:
          return True# so keep runing loop to recalc mean and re classify centroids
      return False

    def SSE(self):
      sse = 0
      size_matrix = []
      print('K', self.k)
      for i in range(0,self.k):
        counter = 0
        for j in range(len(self.df)):
          if self.classify[j,0] == i:
              counter = counter + 1
        
        size_matrix.append("{first}: {second} tweets".format(first = i+1,second = counter))

        location = np.zeros(counter).astype(dtype='int')
        X = pd.DataFrame(index=range(len(location)),columns=range(1))
        counter = 0

        for j in range(len(self.df)):
          if self.classify[j,0] == i:
              location[counter] = j
              X.iloc[counter,0] = self.df.iloc[j,0]
              counter = counter + 1
        center = self.centroids[i,0].split()   
        
        for f in range(len(X)):
          test = X.iloc[f,0].split()

          count = 0
          length = 0
          if len(center) > len(test):
            size = len(center)
          else:
            size = len(test)
          for i in range(0,size):
            if len(center) > len(test):
              for j in range(0,len(test)):
                if center[i] == test[j]:

                  count = count + 1
                  length = length + len(center[i])
            else:
              for j in range(0,len(center)):
                if center[j] == test[i]:
        
                  count = count + 1
                  length = length + len(test[i])
          metric = 0
          if count == 0:
            metric = 1
          elif count == len(center) or count == len(test):
            metric = 0
          else:
            metric = 1 - count/length
          sse = sse + pow(metric,2)
      fig = go.Figure(data=[go.Table(header=dict(values=['Value of K', 'SSE','Size of each cluster']),
                      cells=dict(values=[self.k, sse,size_matrix]))
                          ])
      fig.show()    

    def algorithm(self): 
      g =1
      while self.check():
        print('iterations: ', g)
        #print('  distance matrix')
        self.distance_matrix() 
        #print('  classification')
        self.classification()
        #print('  calc centroid')
        for r in range(0,self.k):
          self.calc_centroid(r)
        g = g+1
        #if self.check():
          #break
      #print('  SSE')
      self.SSE()

    def calc_centroid(self,m):
      counter = 0
      for j in range(0,len(self.df)):
        if self.classify[j,0] == m:
            counter = counter + 1
      location = np.zeros(counter).astype(dtype='int')
      X = pd.DataFrame(index=range(len(location)),columns=range(1))
      values = np.zeros(len(X))
      #print("    {first}: {second} tweets".format(first = m+1,second = counter))
      counter = 0

      for j in range(len(self.df)):
        if self.classify[j,0] == m:
            location[counter] = j
            X.iloc[counter,0] = self.df.iloc[j,0]
            counter = counter + 1

      for i in range(len(X)):
        center = X.iloc[i,0].split() 
        sum = 0
        for f in range(len(X)):
          test = X.iloc[f,0].split()
          count = 0
          length = 0
          if len(center) > len(test):
            size = len(center)
          else:
            size = len(test)
          for p in range(0,size):
            if len(center) > len(test):
              for j in range(len(test)):
                if center[p] == test[j]:
                  count = count + 1
                  length = length + len(center[p])
            else:
              for j in range(len(center)):
                if center[j] == test[p]:
                  count = count + 1
                  length = length + len(test[p])

          if count == 0:
            sum = sum + 1
          elif count == len(center) or count == len(test):
            sum = sum + 0
          else:
            sum = sum + (1 - count/length)
      
        
        values[i] = sum/len(X)
      minimum = 1000
      val = 0
      for i in range(len(X)):
        if values[i] < minimum:
          minimum = values[i]
          val = i
      self.centroids[m,0] = X.iloc[val,0]

#######################################################################################
########################################################################################
#######################################################################################
###########################################################################################
#############################################################################################
kluster = 13
k_means= kmeans(datafiles,kluster)
k_means.algorithm()

